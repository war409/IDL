
PRO TEMP

  ; SET THE COLOR TABLE TYPE
  XCOLORS, TITLE='Load Colour Table For Input Data', COLORINFO=COLORINFO_STRUCT, /BLOCK
  ;--------------
  ; SET COLOR TABLE PARAMETERS
  CT_RED = COLORINFO_STRUCT.R
  CT_GREEN = COLORINFO_STRUCT.G
  CT_BLUE = COLORINFO_STRUCT.B
  CT_TYPE = COLORINFO_STRUCT.TYPE
  CT_NAME = COLORINFO_STRUCT.NAME
  CT_INDEX = COLORINFO_STRUCT.INDEX

  FILE_IN = 'C:\WorkSpace\Guy\In\2009.057.img'

    ENVI_OPEN_FILE, FILE_IN, R_FID=FID_IN, /NO_REALIZE ; OPEN FILE
    ;--------------
    ; GET MAP INFORMATION:
    ;--------------    
    ENVI_FILE_QUERY, FID_IN, DIMS=DIMS, NS=NS, NL=NL, NB=NB, BNAMES=BNAMES, FNAME=FNAME, DATA_TYPE=DT
    DIMS_IN = [NS, NL] ; SET FILE DIMENSIONS
    MAPINFO = ENVI_GET_MAP_INFO(FID=FID_IN)
    PROJFULL = MAPINFO.PROJ
    DATUM = MAPINFO.PROJ.DATUM
    PROJ = MAPINFO.PROJ.NAME
    UNITS = MAPINFO.PROJ.UNITS
    CXSIZE = DOUBLE(MAPINFO.PS[0])
    CYSIZE = DOUBLE(MAPINFO.PS[1])
    LEFT = DOUBLE(MAPINFO.MC[2])
    TOP = DOUBLE(MAPINFO.MC[3])
    RIGHT = LEFT + (DOUBLE(DIMS_IN[0]) * DOUBLE(CXSIZE))
    BOTTOM = TOP - (DOUBLE(DIMS_IN[1]) * DOUBLE(CYSIZE))


    

      RED_FM = 'C:\WorkSpace\Guy\MODIS\MOD09A1.2000.049.aust.005.b01.500m_0620_0670nm_refl.img'
      GREEN_FM = 'C:\WorkSpace\Guy\MODIS\MOD09A1.2000.049.aust.005.b04.500m_0545_0565nm_refl.img'
      BLUE_FM = 'C:\WorkSpace\Guy\MODIS\MOD09A1.2000.049.aust.005.b03.500m_0459_0479nm_refl.img'    
      ENVI_OPEN_FILE, RED_FM, R_FID=FID_RM, /NO_REALIZE ; OPEN FILE
      ENVI_OPEN_FILE, GREEN_FM, R_FID=FID_GM, /NO_REALIZE ; OPEN FILE      
      ENVI_OPEN_FILE, BLUE_FM, R_FID=FID_BM, /NO_REALIZE ; OPEN FILE      
      ;--------------
      ; GET MAP INFORMATION: GET NEW POS - LATMIN ETC - FROM DIMENSIONS
      ;--------------    
      ENVI_FILE_QUERY, FID_RM, DIMS=DIMS2, NS=NS_RM, NL=NL_RM, NB=NB_RM, FNAME=FNAME_RM, DATA_TYPE=DT_RM
      DIMS_RM = [NS_RM, NL_RM] ; SET FILE DIMENSIONS
      MAPINFO_RM = ENVI_GET_MAP_INFO(FID=FID_RM)
      PROJFULL_RM = MAPINFO_RM.PROJ
      DATUM_RM = MAPINFO_RM.PROJ.DATUM
      PROJ_RM = MAPINFO_RM.PROJ.NAME
      UNITS_RM = MAPINFO_RM.PROJ.UNITS
      CXSIZE_RM = DOUBLE(MAPINFO_RM.PS[0])
      CYSIZE_RM = DOUBLE(MAPINFO_RM.PS[1])
      LEFT_RM = DOUBLE(MAPINFO_RM.MC[2])
      TOP_RM = DOUBLE(MAPINFO_RM.MC[3])
      RIGHT_RM = LEFT_RM + (DOUBLE(DIMS_RM[0]) * DOUBLE(CXSIZE_RM))
      BOTTOM_RM = TOP_RM - (DOUBLE(DIMS_RM[1]) * DOUBLE(CYSIZE_RM))
      
      DATA_RM = ENVI_GET_DATA(FID=FID_RM, DIMS=DIMS2, POS=0) ; GET DATA
      DATA_GM = ENVI_GET_DATA(FID=FID_GM, DIMS=DIMS2, POS=0) ; GET DATA      
      DATA_BM = ENVI_GET_DATA(FID=FID_BM, DIMS=DIMS2, POS=0) ; GET DATA 
      
    ; LOAD COLOUR TABEL
    ;DEVICE, DECOMPOSED = 0
    ;TVLCT, CT_RED, CT_GREEN, CT_BLUE  
    ;--------------
    ; SET WINDOW PARAMETERS:
    ;--------------
    ;DEVICE, GET_SCREEN_SIZE=SSIZE ; DISPLAY DIMENSIONS (FAKE HIDE DEVICE WINDOW)
    XRANGE = [MIN(LEFT), MAX(RIGHT)]
    YRANGE = [MIN(BOTTOM), MAX(TOP)]
    ASPECTRATIO = ABS(YRANGE[1] - YRANGE[0]) / ABS(XRANGE[1]-XRANGE[0])
    IF ASPECTRATIO LE 1 THEN BEGIN ; YRANGE IS GE XRANGE
      WINDOW, XSIZE=1000, YSIZE=1000*ASPECTRATIO ;, XPOS=SSIZE[0], YPOS=SSIZE[1] , /FREE
    ENDIF ELSE BEGIN ; YRANGE IS LT XRANGE
      WINDOW, XSIZE=1000*ASPECTRATIO, YSIZE=1000 ;, XPOS=SSIZE[0], YPOS=SSIZE[1] , /FREE
    ENDELSE
    
    ;Window, Title='Direct Graphics Alpha Blending', XSIZE=750, YSIZE=750
    
    ;--------------
    ; ESTABLISH THE MAP SPACE (SET MAP PROJECTION OF DISPLAY WINDOW) - Default is Cylindrical Equidistant
    ;MAP_SET, LIMIT=[BOTTOM, LEFT, TOP, RIGHT], /NOBORDER  
    MAP_SET, LIMIT=[TOP, LEFT, BOTTOM, RIGHT], /NOBORDER
    ;--------------      
      
      
      ;--------------
      ; APPLY NEW LIMITS
      l = WHERE(DATA_RM LT 0, COUNT_l) ; GET POSITION OF VALUES LT LOW
      IF (COUNT_l GT 0) THEN DATA_RM[l] = 0 ; SET VALUES LT LOW TO THE MINIMUM LIMIT VALUE
      h = WHERE(DATA_RM GT 5000, COUNT_h) ; GET POSITION OF VALUES GT HIGH
      IF (COUNT_h GT 0) THEN DATA_RM[h] = 5000 ; SET VALUES GT HIGH TO THE MAXIMUM LIMIT VALUE
      
      l = WHERE(DATA_GM LT 0, COUNT_l) ; GET POSITION OF VALUES LT LOW
      IF (COUNT_l GT 0) THEN DATA_GM[l] = 0 ; SET VALUES LT LOW TO THE MINIMUM LIMIT VALUE
      h = WHERE(DATA_GM GT 5000, COUNT_h) ; GET POSITION OF VALUES GT HIGH
      IF (COUNT_h GT 0) THEN DATA_GM[h] = 5000 ; SET VALUES GT HIGH TO THE MAXIMUM LIMIT VALUE
      
      l = WHERE(DATA_BM LT 0, COUNT_l) ; GET POSITION OF VALUES LT LOW
      IF (COUNT_l GT 0) THEN DATA_BM[l] = 0 ; SET VALUES LT LOW TO THE MINIMUM LIMIT VALUE
      h = WHERE(DATA_BM GT 5000, COUNT_h) ; GET POSITION OF VALUES GT HIGH
      IF (COUNT_h GT 0) THEN DATA_BM[h] = 5000 ; SET VALUES GT HIGH TO THE MAXIMUM LIMIT VALUE            
      ;--------------
      ; APPLY BYTE STRETCH:
      ;--------------
      RANGE_X = 255 ; SET NEW HISTOGRAM RANGE 
      RANGE_DATA = (MAX(DATA_RM, /NAN) - MIN(DATA_RM, /NAN)) ; SET ORIGINAL HISTOGRAM RANGE (Maximum of DATA - Minimum of Data)
      SLOPE = (RANGE_X / RANGE_DATA) * 1.00 ; CALCULATE SLOPE
      INTERCEPT = (SLOPE * MIN(DATA_RM, /NAN)) ; CALCULATE INTERCEPT
      DATA_RM2 = FIX((0.051*DATA_RM)-INTERCEPT) ; APPLY STRETCH
      DATA_RM_PNG = BYTE(TEMPORARY(DATA_RM2)) ; CONVERT DATATYPE TO BYTE
      
      RANGE_DATA = (MAX(DATA_GM, /NAN) - MIN(DATA_GM, /NAN)) ; SET ORIGINAL HISTOGRAM RANGE (Maximum of DATA - Minimum of Data)
      SLOPE = (RANGE_X / RANGE_DATA) * 1.00 ; CALCULATE SLOPE
      INTERCEPT = (SLOPE * MIN(DATA_GM, /NAN)) ; CALCULATE INTERCEPT
      DATA_GM2 = FIX((0.051*DATA_GM)-INTERCEPT) ; APPLY STRETCH
      DATA_GM_PNG = BYTE(TEMPORARY(DATA_GM2)) ; CONVERT DATATYPE TO BYTE
      
      RANGE_DATA = (MAX(DATA_BM, /NAN) - MIN(DATA_BM, /NAN)) ; SET ORIGINAL HISTOGRAM RANGE (Maximum of DATA - Minimum of Data)
      SLOPE = (RANGE_X / RANGE_DATA) * 1.00 ; CALCULATE SLOPE
      INTERCEPT = (SLOPE * MIN(DATA_BM, /NAN)) ; CALCULATE INTERCEPT
      DATA_BM2 = FIX((0.051*DATA_BM)-INTERCEPT) ; APPLY STRETCH
      DATA_BM_PNG = BYTE(TEMPORARY(DATA_BM2)) ; CONVERT DATATYPE TO BYTE      
      ;--------------
      ; WARP THE INPUT DATA TO THE MAP SPACE
      RM_IMAGE = MAP_IMAGE(DATA_RM_PNG, STARTX, STARTY, XSIZE, YSIZE, COMPRESS=1, MAP_STRUCTURE=PROJ_RM, $
        LATMIN=TOP_RM, LONMIN=LEFT_RM, LATMAX=BOTTOM_RM, LONMAX=RIGHT_RM)
        ;LATMIN=BOTTOM_RM, LONMIN=LEFT_RM, LATMAX=TOP_RM, LONMAX=RIGHT_RM)
      GM_IMAGE = MAP_IMAGE(DATA_GM_PNG, STARTX, STARTY, XSIZE, YSIZE, COMPRESS=1, MAP_STRUCTURE=PROJ_RM, $
        LATMIN=TOP_RM, LONMIN=LEFT_RM, LATMAX=BOTTOM_RM, LONMAX=RIGHT_RM)
      BM_IMAGE = MAP_IMAGE(DATA_BM_PNG, STARTX, STARTY, XSIZE, YSIZE, COMPRESS=1, MAP_STRUCTURE=PROJ_RM, $
        LATMIN=TOP_RM, LONMIN=LEFT_RM, LATMAX=BOTTOM_RM, LONMAX=RIGHT_RM)
      ;--------------
      IMAGE_RGB = [[[RM_IMAGE]], [[GM_IMAGE]], [[BM_IMAGE]]] ; BUILD THE IMAGE

      DEVICE, DECOMPOSED=1

      TVIMAGE, IMAGE_RGB, STARTX, STARTY, XSIZE=XSIZE, YSIZE=YSIZE, TRUE=3, /TV

      IMAGE_RGB2 = Transpose(IMAGE_RGB, [2,0,1])
      WRITE_PNG, 'C:\WorkSpace\Guy\test.png', IMAGE_RGB2

      ; DRAW WARPED IMAGE IN THE DISPLAY WINDOW
      TVIMAGE, MODIS_IMAGE, STARTX, STARTY, XSIZE=XSIZE, YSIZE=YSIZE, /TV ;, /ORDER

      PRINT,''


END