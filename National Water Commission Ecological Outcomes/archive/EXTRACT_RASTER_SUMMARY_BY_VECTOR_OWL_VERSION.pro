; ######################################################################
; NAME: EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION.pro
; LANGUAGE: IDL
; AUTHOR: Garth Warren 
; DATE: 31/09/2009
; DLM: 23/10/2009
; DESCRIPTION: This tool extracts a summary (mean, median, stddev, min 
;              & max) of the input cell data where the user-selected 
;              vector (ROI) intersect the input raster image.
;              The OWL version contains additional output fields;
;              the proportion of pixels that meet set OWL thresholds.
;              For example, 'PRCNT_GT_10' is the percentage of pixels
;              within the ROI that have an OWL value of greater than 10.
;              Note that NoData (cloud) pixels are excluded from the 
;              calculation.
; INPUT: Single or multi-band raster; polygon or point feature class
; OUTPUT: Text or CSV file (inc. file extension in output file name)
; SET PARAMETERS: WIDGET Based input; DEFINE OUTPUT CSV FILE, DEFINE 
;                 INPUT IMAGE DATA; DEFINE ROI. OTHER input; SET NODATA VALUES TO 
;                 NaN (set NoData Value)
; NOTES: A polygon or point vector must be opened in ENVI and associated
;        with the input raster data as a ROI. When extracting data at 
;        multiple polygon ROI please open each polygon as individual 
;        ROIs.
; ######################################################################
;
PRO EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION
  PRINT,''
  PRINT,'BEGIN PROCESSING: EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION'
  PRINT,'' 
  ;
  PRINT, '  DEFINE OUTPUT CSV FILE'
  ; DEFINE OUTPUT CSV FILE
  OUTFILE=DIALOG_PICKFILE(TITLE='Enter Output File Name')
  ; CHECK WHETHER THE OUTPUT FILE NAME AND PATH IS VALID
  IF OUTFILE EQ '' THEN BEGIN
  PRINT,''
  PRINT, 'The Selected Output File Name Is Not Valid'
  PRINT,''
  RETURN
  ENDIF
  ; CREATE THE EMPTY OUTPUT FILE
  OPENW, OUTLUN, OUTFILE, /GET_LUN
  ;
  PRINT, '  DEFINE INPUT IMAGE DATA'
  ; DEFINE INPUT IMAGE DATA (SINGLE OR MULTIBAND)
  ENVI_SELECT, TITLE='Select Input Image Data', FID=FID, POS=POS
  ; CHECK WHETHER THE INPUT IMAGE DATA NAME AND PATH IS VALID
  IF (FID EQ -1) THEN BEGIN
  PRINT,''
  PRINT, 'The Selected Image File Is Not Valid'
  PRINT,''
  RETURN
  ENDIF
  ENVI_FILE_QUERY, FID, BNAME=BNAME, SNAME=SNAME, NB=NB, DATA_TYPE=DATA_TYPE
  ; SET FILE COLUMN HEADER
  FNAME=["RASTERID","FILE&BAND","ROI","MEAN","STDDEV","MEDIAN","MIN","MAX","NO_255","NO_NOT_255","PRCT_EQ_255", $
    "PRCT_VALID_GT_10","PRCT_VALID_GT_20","PRCT_VALID_GT_30", "PRCT_VALID_GT_40","PRCT_VALID_GT_50", $
    "PRCT_VALID_GT_60","PRCT_VALID_GT_70","PRCT_VALID_GT_80","PRCT_VALID_GT_90","PRCT_ALL_GT_10", "PRCT_ALL_GT_20", $
    "PRCT_ALL_GT_30", "PRCT_ALL_GT_40","PRCT_ALL_GT_50","PRCT_ALL_GT_60","PRCT_ALL_GT_70", "PRCT_ALL_GT_80","PRCT_ALL_GT_90"]
  PRINTF, FORMAT='(10000(A,:,","))', OUTLUN, '"' + FNAME + '"'
  ; COUNT THE NUMBER OF BANDS IN THE INPUT FILE
  BCOUNT = WHERE(BNAME, COUNT)
  ;
  ;CHECK IF THE INPUT ROIs ARE ASSOCIATED WITH THE INPUT IMAGE DATA
  ROI_IDS = ENVI_GET_ROI_IDS(FID=FID, ROI_NAME=ROI_NAME, /SHORT_NAME)
  ; IF INPUT ROI IS NOT VALID PRINT... 
  IF (ROI_IDS[0] EQ -1) THEN BEGIN
  PRINT,''
  PRINT, 'There Is No ROI Associated With The Selected Input Image'
  PRINT,''
  RETURN
  ENDIF
  ;
  ; WIDGET FOR THE ROI SELECTION
  BASE = WIDGET_AUTO_BASE(TITLE='Select ROI')
  WM   = WIDGET_MULTI(BASE, LIST=ROI_NAME, UVALUE='LIST', /AUTO)
  RESULT = AUTO_WID_MNG(BASE)
  ;
  ; ERROR CHECK
  IF (RESULT.ACCEPT EQ 0) THEN RETURN
  PTR = WHERE(RESULT.LIST EQ 1, COUNT)
  ;
  ; ROI DATA EXTRACTION: BAND LOOP
  FOR i=0, COUNT-1 DO BEGIN
    ;
    ;INITIALISE VARIABLE TEMP_DATA TO HOLD ROI-BASED DATA
    DATA = ENVI_GET_ROI_DATA(ROI_IDS[PTR[i]], FID=FID, $
      POS=[0])
    TEMP_DATA = DBLARR(N_ELEMENTS(POS),N_ELEMENTS(DATA))
    ;
    ; ROI DATA EXTRACTION: ROI LOOP
    ; EXTRACT THE DATA AT EACH CELL IN THE ROI
    FOR j=0, N_ELEMENTS(POS)-1 DO BEGIN
      DATA = ENVI_GET_ROI_DATA(ROI_IDS[PTR[i]], FID=FID, $
        POS=POS[j])
      TEMP_DATA[j,*] = DATA
      ; GET ROI NAME
      RESULT = ENVI_GET_ROI(ROI_IDS[PTR[i]], ROI_NAME=ROI_NAME)            
      ;
      ; CALCULATE & WRITE
      ; CHECK DATA TYPE IS FLOAT
      IF DATA_TYPE LT 4 OR DATA_TYPE GT 5 THEN BEGIN
      ; CONVERT TEMP_DATA ARRAY TO FLOAT
      TEMP_DATA = FLOAT(TEMP_DATA)
      ENDIF
      ; GET OWL SUMMARY SPECIAL 1 ; THE PROPORTION OF VALUES THAT MEET THE SET CONDITION
      ; GET THE PERCENTAGE OF VALUES EQUAL TO NODATA   
      NP0 = WHERE(TEMP_DATA[j,*] EQ 255.000, COUNT=COUNT_YES, NCOMPLEMENT=COUNT_NO)
      ; IF NO NAN VALUES
      IF COUNT_YES EQ 0 THEN BEGIN
        COUNT_YES = 0
        COUNT_NOD = DOUBLE(COUNT_NO)
        TOTALCOUNT = (COUNT_YES + COUNT_NOD)
        NP0PROP = COUNT_YES/TOTALCOUNT
        ;
        NO_NAN = COUNT_YES
        NO_VALID = COUNT_NO
      ENDIF ELSE BEGIN
        ; IF NO VALID VALUES
        IF COUNT_NO EQ 0 THEN BEGIN
          COUNT_NO = 0
          COUNT_YESD = DOUBLE(COUNT_YES)
          TOTALCOUNT = (COUNT_YESD + COUNT_NO)
          NP0PROP = COUNT_YESD/TOTALCOUNT
          ;
          NO_NAN = COUNT_YES
          NO_VALID = COUNT_NO
        ENDIF ELSE BEGIN
          ; IF THERE ARE NAN AND VALID VALUES
          COUNT_YESD = DOUBLE(COUNT_YES)
          COUNT_NOD = DOUBLE(COUNT_NO)
          TOTALCOUNT = (COUNT_YESD + COUNT_NOD)
          NP0PROP = COUNT_YESD/TOTALCOUNT
          ;
          NO_NAN = COUNT_YES
          NO_VALID = COUNT_NO
        ENDELSE
      ENDELSE
      ; --------------------------------------------------------------------------------
      PRINT, '  CALCULATE ROI SUMMARY & WRITE'
      ; SET NODATA VALUES TO NaN IN TEMP_DATA ARRAY
      k = WHERE(TEMP_DATA EQ 255.000, COUNT)      
      IF (COUNT GT 0) THEN TEMP_DATA[k] = !VALUES.F_NAN
      ;
      ; GET OWL SUMMARY SPECIAL 2 ; THE PROPORTION OF VALUES THAT MEET THE SET CONDITION
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 10
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP1PROP = 'NaN' 
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
        NP1 = WHERE(FINITE(TEMP_DATA[j,*]) GT 10.000, COUNT, NCOMPLEMENT=COUNTLESS)
        ; IF NO VALUES LESS THAN THE THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          COUNTLESSD = DOUBLE(COUNTLESS)
          TOTALCOUNT = (COUNT + COUNTLESSD)
          NP1PROP = COUNT/TOTALCOUNT
        ENDIF ELSE BEGIN
          ; IF NO VALUES GREATER THAN THE THRESHOLD
          IF COUNTLESS EQ 0 THEN BEGIN
            COUNTLESS = 0
            COUNTD = DOUBLE(COUNT)
            TOTALCOUNT = (COUNTD + COUNTLESS)
            NP1PROP = COUNTD/TOTALCOUNT
          ENDIF ELSE BEGIN
            ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
            COUNTD = DOUBLE(COUNT)
            COUNTLESSD = DOUBLE(COUNTLESS)
            TOTALCOUNT = (COUNTD + COUNTLESSD)
            NP1PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP1PROP GT 0.0 THEN BEGIN
        NP1PROPx = NP1PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP1PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 20
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP2PROP = 'NaN' 
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
        NP2 = WHERE(FINITE(TEMP_DATA[j,*]) GT 20.000, COUNT, NCOMPLEMENT=COUNTLESS)
        ; IF NO VALUES LESS THAN THE THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          COUNTLESSD = DOUBLE(COUNTLESS)
          TOTALCOUNT = (COUNT + COUNTLESSD)
          NP2PROP = COUNT/TOTALCOUNT
        ENDIF ELSE BEGIN
          ; IF NO VALUES GREATER THAN THE THRESHOLD
          IF COUNTLESS EQ 0 THEN BEGIN
            COUNTLESS = 0
            COUNTD = DOUBLE(COUNT)
            TOTALCOUNT = (COUNTD + COUNTLESS)
            NP2PROP = COUNTD/TOTALCOUNT
          ENDIF ELSE BEGIN
            ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
              COUNTD = DOUBLE(COUNT)
              COUNTLESSD = DOUBLE(COUNTLESS)
              TOTALCOUNT = (COUNTD + COUNTLESSD)
              NP2PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP2PROP GT 0.0 THEN BEGIN
        NP2PROPx = NP2PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP2PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 30
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP3PROP = 'NaN' 
      ENDIF ELSE BEGIN
      ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
      NP3 = WHERE(FINITE(TEMP_DATA[j,*]) GT 30.000, COUNT, NCOMPLEMENT=COUNTLESS) 
      ; IF NO VALUES LESS THAN THE THRESHOLD
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNT + COUNTLESSD)
        NP3PROP = COUNT/TOTALCOUNT
      ENDIF ELSE BEGIN
      ; IF NO VALUES GREATER THAN THE THRESHOLD
      IF COUNTLESS EQ 0 THEN BEGIN
        COUNTLESS = 0
        COUNTD = DOUBLE(COUNT)
        TOTALCOUNT = (COUNTD + COUNTLESS)
        NP3PROP = COUNTD/TOTALCOUNT
      ENDIF ELSE BEGIN
        ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
        COUNTD = DOUBLE(COUNT)
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNTD + COUNTLESSD)
        NP3PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP3PROP GT 0.0 THEN BEGIN
        NP3PROPx = NP3PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP3PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 40
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP4PROP = 'NaN' 
      ENDIF ELSE BEGIN
      ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
      NP4 = WHERE(FINITE(TEMP_DATA[j,*]) GT 40.000, COUNT, NCOMPLEMENT=COUNTLESS)
      ; IF NO VALUES LESS THAN THE THRESHOLD
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNT + COUNTLESSD)
        NP4PROP = COUNT/TOTALCOUNT
      ENDIF ELSE BEGIN
      ; IF NO VALUES GREATER THAN THE THRESHOLD
      IF COUNTLESS EQ 0 THEN BEGIN
        COUNTLESS = 0
        COUNTD = DOUBLE(COUNT)
        TOTALCOUNT = (COUNTD + COUNTLESS)
        NP4PROP = COUNTD/TOTALCOUNT
      ENDIF ELSE BEGIN
        ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
        COUNTD = DOUBLE(COUNT)
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNTD + COUNTLESSD)
        NP4PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP4PROP GT 0.0 THEN BEGIN
        NP4PROPx = NP4PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP4PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 50
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP5PROP = 'NaN' 
      ENDIF ELSE BEGIN
      ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
      NP5 = WHERE(FINITE(TEMP_DATA[j,*]) GT 50.000, COUNT, NCOMPLEMENT=COUNTLESS)
      ; IF NO VALUES LESS THAN THE THRESHOLD
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNT + COUNTLESSD)
        NP5PROP = COUNT/TOTALCOUNT
      ENDIF ELSE BEGIN
      ; IF NO VALUES GREATER THAN THE THRESHOLD
      IF COUNTLESS EQ 0 THEN BEGIN
        COUNTLESS = 0
        COUNTD = DOUBLE(COUNT)
        TOTALCOUNT = (COUNTD + COUNTLESS)
        NP5PROP = COUNTD/TOTALCOUNT
      ENDIF ELSE BEGIN
        ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
        COUNTD = DOUBLE(COUNT)
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNTD + COUNTLESSD)
        NP5PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP5PROP GT 0.0 THEN BEGIN
        NP5PROPx = NP5PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP5PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 60
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP6PROP = 'NaN' 
      ENDIF ELSE BEGIN
      ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
      NP6 = WHERE(FINITE(TEMP_DATA[j,*]) GT 60.000, COUNT, NCOMPLEMENT=COUNTLESS)
      ; IF NO VALUES LESS THAN THE THRESHOLD
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNT + COUNTLESSD)
        NP6PROP = COUNT/TOTALCOUNT
      ENDIF ELSE BEGIN
      ; IF NO VALUES GREATER THAN THE THRESHOLD
      IF COUNTLESS EQ 0 THEN BEGIN
        COUNTLESS = 0
        COUNTD = DOUBLE(COUNT)
        TOTALCOUNT = (COUNTD + COUNTLESS)
        NP6PROP = COUNTD/TOTALCOUNT
      ENDIF ELSE BEGIN
        ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
        COUNTD = DOUBLE(COUNT)
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNTD + COUNTLESSD)
        NP6PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP6PROP GT 0.0 THEN BEGIN
        NP6PROPx = NP6PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP6PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 70
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP7PROP = 'NaN' 
      ENDIF ELSE BEGIN
      ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
      NP7 = WHERE(FINITE(TEMP_DATA[j,*]) GT 70.000, COUNT, NCOMPLEMENT=COUNTLESS)
      ; IF NO VALUES LESS THAN THE THRESHOLD
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNT + COUNTLESSD)
        NP7PROP = COUNT/TOTALCOUNT
      ENDIF ELSE BEGIN
      ; IF NO VALUES GREATER THAN THE THRESHOLD
      IF COUNTLESS EQ 0 THEN BEGIN
        COUNTLESS = 0
        COUNTD = DOUBLE(COUNT)
        TOTALCOUNT = (COUNTD + COUNTLESS)
        NP7PROP = COUNTD/TOTALCOUNT
      ENDIF ELSE BEGIN
        ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
        COUNTD = DOUBLE(COUNT)
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNTD + COUNTLESSD)
        NP7PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP7PROP GT 0.0 THEN BEGIN
        NP7PROPx = NP7PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP7PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 80
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP8PROP = 'NaN' 
      ENDIF ELSE BEGIN
      ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
      NP8 = WHERE(FINITE(TEMP_DATA[j,*]) GT 80.000, COUNT, NCOMPLEMENT=COUNTLESS)
      ; IF NO VALUES LESS THAN THE THRESHOLD
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNT + COUNTLESSD)
        NP8PROP = COUNT/TOTALCOUNT
      ENDIF ELSE BEGIN
      ; IF NO VALUES GREATER THAN THE THRESHOLD
      IF COUNTLESS EQ 0 THEN BEGIN
        COUNTLESS = 0
        COUNTD = DOUBLE(COUNT)
        TOTALCOUNT = (COUNTD + COUNTLESS)
        NP8PROP = COUNTD/TOTALCOUNT
      ENDIF ELSE BEGIN
        ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
        COUNTD = DOUBLE(COUNT)
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNTD + COUNTLESSD)
        NP8PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP8PROP GT 0.0 THEN BEGIN
        NP8PROPx = NP8PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP8PROPx = 0.00
      ENDELSE
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 90
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP9PROP = 'NaN' 
      ENDIF ELSE BEGIN
      ; GET COUNT OF VALUES ABOVE AND BELOW THE THRESHOLD
      NP9 = WHERE(FINITE(TEMP_DATA[j,*]) GT 90.000, COUNT, NCOMPLEMENT=COUNTLESS)    
      ; IF NO VALUES LESS THAN THE THRESHOLD
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNT + COUNTLESSD)
        NP9PROP = COUNT/TOTALCOUNT
      ENDIF ELSE BEGIN
      ; IF NO VALUES GREATER THAN THE THRESHOLD
      IF COUNTLESS EQ 0 THEN BEGIN
        COUNTLESS = 0
        COUNTD = DOUBLE(COUNT)
        TOTALCOUNT = (COUNTD + COUNTLESS)
        NP9PROP = COUNTD/TOTALCOUNT
      ENDIF ELSE BEGIN
        ; IF  VALUES GREATER THAN AND LESS THAN THE THRESHOLD
        COUNTD = DOUBLE(COUNT)
        COUNTLESSD = DOUBLE(COUNTLESS)
        TOTALCOUNT = (COUNTD + COUNTLESSD)
        NP9PROP = COUNTD/TOTALCOUNT 
          ENDELSE
        ENDELSE
      ENDELSE
      ;
      IF NP9PROP GT 0.0 THEN BEGIN
        NP9PROPx = NP9PROP + NP0PROP
        ENDIF ELSE BEGIN
          NP9PROPx = 0.00
      ENDELSE
      ;  
      ; GET MIN MAX
      OUTMIN = MIN(TEMP_DATA[j,*], DIMENSION=0, MAX=OUTMAX, /NAN)
      ; GET MEAN
      OUTMEAN = MEAN(TEMP_DATA[j,*], /NAN) 
      ; GET STDDEV
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        OUTSTDDEV = 'NaN' 
      ENDIF ELSE BEGIN
        OUTSTDDEV = STDDEV(TEMP_DATA[j,*], /NAN)
      ENDELSE
      ;
      ; GET MEDIAN
      OUTMEDIAN = MEDIAN(TEMP_DATA[j,*], DIMENSION=0, /EVEN)
      ;
      ; WRITE THE ROI SUMMARY DATA TO THE OUTPUT CSV FILE
      ; GET BAND NAME
      NEWBNAME = BNAME[j]
      ; GET BAND & FILE NAME
      IRNAME = SNAME + ':' + BNAME[j]
      PRINTF, FORMAT='(10000(A,:,","))', OUTLUN, j, '"' + NEWBNAME + '"', '"' + ROI_NAME + '"', $
        OUTMEAN, OUTSTDDEV, OUTMEDIAN, OUTMIN, OUTMAX, NO_NAN, NO_VALID, NP0PROP, NP1PROP, $
        NP2PROP, NP3PROP, NP4PROP, NP5PROP, NP6PROP, NP7PROP, NP8PROP, NP9PROP, $ 
        NP1PROPx, NP2PROPx, NP3PROPx, NP4PROPx, NP5PROPx, NP6PROPx, NP7PROPx, NP8PROPx, NP9PROPx
      ;
      ; LOOP BACK TO THE NEXT ROI IN THE LIST
    ENDFOR
    ;
    ; LOOP BACK TO THE NEXT BAND IN THE LIST
  ENDFOR
  ;
  ; CLOSE THE OUTPUT FILE
  FREE_LUN, OUTLUN
  ;
  PRINT,''
  PRINT,'FINISHED PROCESSING: EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION'
  PRINT,''
END