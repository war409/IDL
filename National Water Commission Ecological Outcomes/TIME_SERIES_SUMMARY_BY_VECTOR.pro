; ######################################################################
; NAME: TIME_SERIES_SUMMARY_BY_VECTOR.pro
; LANGUAGE: IDL
; AUTHOR: Garth Warren
; DATE: 11/11/2009
; DLM: 20/11/2009
; DESCRIPTION: EXTRACT TIME SERIES SUMMARY: mNDWI NDVI VERSION.
; INPUT: SINGLE OR MULTIBAND IMAGE DATA. ONE OR MORE ROI.
; OUTPUT: TEXT OR CSV FILE.
; SET PARAMETERS: VIA ENVI WIDGETS.
; NOTES: THE ROI MUST BE ASSOCIATED WITH THE INPUT IMAGE DATA.
; ######################################################################
;
PRO TIME_SERIES_SUMMARY_BY_VECTOR
  ; GET START TIME FOR WHOLE
  F_TIME = SYSTIME(1)
  PRINT,''
  PRINT,'BEGIN PROCESSING: TIME_SERIES_SUMMARY_BY_VECTOR'
  PRINT,''
  ;---------------------------------------------------------------------
  ; SELECT OUTPUT SUMMARY FILE
  OUTFILE=DIALOG_PICKFILE(TITLE='ENTER OUTPUT FILE NAME AND EXTENSION')
  ; ERROR CHECK
  IF OUTFILE EQ '' THEN BEGIN
    PRINT,''
    PRINT, 'THE SELECTED OUTPUT IS NOT VALID'
    PRINT,''
    RETURN
  ENDIF
  ; WRITE THE EMPTY OUTPUT FILE
  OPENW, OUTLUN, OUTFILE, /GET_LUN
  ; WRITE FILE HEADER
  FNAME=["RASTERID","BAND","DATE","YEAR","DOY","ROI","MEAN","STDDEV","MEDIAN","MIN","MAX","NO_PIXELS","NO_255","NO_NOT_255", $
    "PROP_EQ_255", "PROP_GE_NEG_0P9", "PROP_GE_NEG_0P8", "PROP_GE_NEG_0P7", "PROP_GE_NEG_0P6", "PROP_GE_NEG_0P5", $
    "PROP_GE_NEG_0P4", "PROP_GE_NEG_0P3", "PROP_GE_NEG_0P2", "PROP_GE_NEG_0P1", "PROP_GE_NEG_0P05", $
    "PROP_GE_0", "PROP_GT_0", "PROP_GE_0P05", "PROP_GE_0P1","PROP_GE_0P2", "PROP_GE_0P3", "PROP_GE_0P4", $
    "PROP_GE_0P5", "PROP_GE_0P6", "PROP_GE_0P7", "PROP_GE_0P8","PROP_GE_0P9"]
  ; WRITE
  PRINTF, FORMAT='(10000(A,:,","))', OUTLUN, '"' + FNAME + '"'
  ;---------------------------------------------------------------------
  ; SELECT INPUT IMAGE DATA (SINGLE OR MULTIBAND)
  ENVI_SELECT, TITLE='SELECT INPUT IMAGE DATA', FID=FID, POS=POS
  ; ERROR CHECK
  IF (FID EQ -1) THEN BEGIN
    PRINT,''
    PRINT, 'THE SELECTED IMAGE FILE IS NOT VALID'
    PRINT,''
    RETURN
  ENDIF
  ; QUERY FILE
  ENVI_FILE_QUERY, FID, BNAME=BNAME, SNAME=SNAME, NB=NB, DATA_TYPE=DATA_TYPE
  ; COUNT THE NUMBER OF BANDS IN THE INPUT FILE
  BCOUNT = WHERE(BNAME, COUNT)
  ;---------------------------------------------------------------------
  ; GET ROI ASSOCIATED WITH THE INPUT IMAGE
  ROI_IDS = ENVI_GET_ROI_IDS(FID=FID, ROI_NAME=ROI_NAME, /SHORT_NAME)
  ; ERROR CHECK
  IF (ROI_IDS[0] EQ -1) THEN BEGIN
    PRINT,''
    PRINT, 'NO ROI ASSOCIATED WITH THE INPUT IMAGE'
    PRINT,''
    RETURN
  ENDIF
  ;---------------------------------------------------------------------
  ; SELECT ROI
  ; ROI SELECTION WIDGET
  BASE = WIDGET_AUTO_BASE(TITLE='SELECT ONE OR MORE ROI')
  WM   = WIDGET_MULTI(BASE, LIST=ROI_NAME, UVALUE='LIST', /AUTO)
  RESULT = AUTO_WID_MNG(BASE)
  ; ERROR CHECK
  IF (RESULT.ACCEPT EQ 0) THEN BEGIN
    PRINT,''
    PRINT, 'THE SELECTED ROI IS NOT VALID'
    PRINT,''
    RETURN
  ENDIF
  ; ASSIGN RESULTS TO POINTER
  PTR = WHERE(RESULT.LIST EQ 1, COUNT)
  RCOUNT = COUNT
  ;---------------------------------------------------------------------
  ; ROI LOOP
  FOR i=0, RCOUNT-1 DO BEGIN ; FOR 'i' START
    ; GET DATA AT ROI[i]
    DATA1 = ENVI_GET_ROI_DATA(ROI_IDS[PTR[i]], FID=FID, POS=[0])
    ; CREATE VARIABLE 'TEMP_DATA'
    TEMP_DATA = DBLARR(N_ELEMENTS(POS),N_ELEMENTS(DATA1))
    ; GET ROI NAME
    RESULT2 = ENVI_GET_ROI(ROI_IDS[PTR[i]], ROI_NAME=ROI_NAME)
    ;-------------------------------------------------------------------
    ; BAND LOOP
    FOR j=0, N_ELEMENTS(POS)-1 DO BEGIN ; FOR 'j' START
      PRINT, 'ROI: ', STRTRIM((i+1), 2), ' OF ', STRTRIM(RCOUNT, 2), ' BAND: ', STRTRIM((j+1), 2), $
        ' OF ', STRTRIM(N_ELEMENTS(POS), 2)
      ; GET DATA AT ROI[i] FOR BAND[j]
      DATA = ENVI_GET_ROI_DATA(ROI_IDS[PTR[i]], FID=FID, POS=POS[j])
      ; FILL ARRAY WITH DATA
      TEMP_DATA[j,*] = DATA
      ;-----------------------------------------------------------------
      ; GET CURRENT BAND NAME
      BNAME2 = BNAME[j]
      ; EXTRACT SHORT NAMES FROM FULL NAMES                   **DEFINE**
      ROINAME = STRMID(ROI_NAME, 12, (STRLEN(ROI_NAME)-12))
      IF (j+1) LT 10 THEN BANDNAME = STRMID(BNAME2, 15, 30)
      IF (((j+1) GE 10) AND ((j+1) LT 100)) THEN BANDNAME = STRMID(BNAME2, 16, 30)
      IF (j+1) GE 100 THEN BANDNAME = STRMID(BNAME2, 17, 30)
      ;-----------------------------------------------------------------
      ; MANIPULATE BANDNAME TO GET DATE                       **DEFINE**
      YYY = STRMID(BANDNAME, 8, 4)
      DOY = STRMID(BANDNAME, 13, 3)
      ; AS CALANDER DATE
      CALDAT, JULDAY(1, DOY, YYY), MONTH, DAY, YEAR
      IF DAY LE 9 THEN DAY = '0' + STRING(STRTRIM(DAY,2)) ELSE DAY = STRING(STRTRIM(DAY,2))
      IF MONTH LE 9 THEN MONTH = '0' + STRING(STRTRIM(MONTH,2)) ELSE MONTH = STRING(STRTRIM(MONTH,2))
      OUTDATE = DAY + '/' + MONTH + '/' + STRING(STRTRIM(YEAR,2))
      ; GET YEAR AND DOY
      YEARP = YYY
      DOYP = DOY
      ;-----------------------------------------------------------------
      ; DATA TYPE CHECK
      IF DATA_TYPE LT 4 OR DATA_TYPE GT 5 THEN BEGIN
        ; CONVERT TEMP_DATA TO FLOAT
        TEMP_DATA[j,*] = FLOAT(TEMP_DATA[j,*])
      ENDIF
      ;-----------------------------------------------------------------
      ; GET PIXEL COUNTS
      ; COUNT THE NUMBER OF ELEMENTS (PIXELS) IN ROI[i] BAND[j]
      COUNT_TOTAL = N_ELEMENTS(TEMP_DATA[j,*])*1.0
      ; COUNT THE NUMBER OF NODATA PIXELS IN ROI[i] BAND[j]
      COUNT_255 = TOTAL(TEMP_DATA[j,*] EQ 255.00)*1.0
      ; COUNT THE NUMBER OF VALID (NOT NODATA) PIXELS IN ROI[i] BAND[j]
      COUNT_VALID = TOTAL(TEMP_DATA[j,*] NE 255.00)*1.0
      ; GET PROPORTIONS:
      EQ_255 = COUNT_255 / COUNT_TOTAL
      ;-----------------------------------------------------------------
      ; RESCALE DATA TO -1 TO 1
      NEWDATA = ((TEMP_DATA[j,*]/100.00)-1)
      ;-----------------------------------------------------------------
      ; ADDED BY JPG !!!!! THE ABOVE LINE TURNS 255's into 1.55 and then all the outputs below include clouds!!
      WHERE_CLOUDS = WHERE(TEMP_DATA[j,*] EQ 255.00, COUNT_CLOUDS)
      IF COUNT_CLOUDS GE 1 THEN NEWDATA[WHERE_CLOUDS] = 255.00 
      ;-----------------------------------------------------------------
      ; CLEAR OLD
      GT_NEG_0P05 = 0
      GT_NEG_0P1 = 0
      GE_0 = 0
      GT_0 = 0
      GE_0P05 = 0
      GE_0P1 = 0
      GE_0P2 = 0
      GE_0P3 = 0
      GE_0P4 = 0
      GE_0P5 = 0
      GE_0P6 = 0
      GE_0P7 = 0
      GE_0P8 = 0
      GE_0P9 = 0
      GE_NEG_0P9 = 0
      GE_NEG_0P8 = 0
      GE_NEG_0P7 = 0
      GE_NEG_0P6 = 0
      GE_NEG_0P5 = 0
      GE_NEG_0P4 = 0
      GE_NEG_0P3 = 0
      GE_NEG_0P2 = 0
      ; GET PROPORTIONS: ALL PIXELS
      GE_NEG_0P05 = TOTAL((NEWDATA GE -0.05) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GT_NEG_0P05 = 'NAN'
      GE_NEG_0P1 = TOTAL((NEWDATA GE -0.1) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GT_NEG_0P1 = 'NAN'
      GE_0 = TOTAL((NEWDATA GE 0.00) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0 = 'NAN'
      GT_0 = TOTAL((NEWDATA GT 0.00) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GT_0 = 'NAN'
      GE_0P05 = TOTAL((NEWDATA GE -0.05) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P05 = 'NAN'
      GE_0P1 = TOTAL((NEWDATA GE 0.1) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P1 = 'NAN'
      GE_0P2 = TOTAL((NEWDATA GE 0.2) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P2 = 'NAN'
      GE_0P3 = TOTAL((NEWDATA GE 0.3) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P3 = 'NAN'
      GE_0P4 = TOTAL((NEWDATA GE 0.4) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P4 = 'NAN'
      GE_0P5 = TOTAL((NEWDATA GE 0.5) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P5 = 'NAN'
      GE_0P6 = TOTAL((NEWDATA GE 0.6) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P6 = 'NAN'
      GE_0P7 = TOTAL((NEWDATA GE 0.7) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P7 = 'NAN'
      GE_0P8 = TOTAL((NEWDATA GE 0.8) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P8 = 'NAN'
      GE_0P9 = TOTAL((NEWDATA GE 0.9) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_0P9 = 'NAN'
      ; PART 2
      GE_NEG_0P9 = TOTAL((NEWDATA GE -0.9) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P9 = 'NAN'
      GE_NEG_0P8 = TOTAL((NEWDATA GE -0.8) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P8 = 'NAN'
      GE_NEG_0P7 = TOTAL((NEWDATA GE -0.7) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P7 = 'NAN'
      GE_NEG_0P6 = TOTAL((NEWDATA GE -0.6) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P6 = 'NAN'
      GE_NEG_0P5 = TOTAL((NEWDATA GE -0.5) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P5 = 'NAN'
      GE_NEG_0P4 = TOTAL((NEWDATA GE -0.4) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P4 = 'NAN'
      GE_NEG_0P3 = TOTAL((NEWDATA GE -0.3) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P3 = 'NAN'
      GE_NEG_0P2 = TOTAL((NEWDATA GE -0.2) AND (NEWDATA NE 255.00)) / COUNT_TOTAL
      IF COUNT_VALID EQ 0 THEN GE_NEG_0P2 = 'NAN'
      ;-----------------------------------------------------------------
      ; SET NODATA PIXELS TO NaN IN TEMP_DATA ARRAY
      k = WHERE(NEWDATA EQ 255.000, COUNT)
      IF (COUNT GT 0) THEN NEWDATA[k] = !VALUES.F_NAN
      ; GET SUMMARY STATISTICS
      ;
      ; GET MIN AND MAX
      OUTMIN = MIN(NEWDATA, DIMENSION=0, MAX=OUTMAX, /NAN)
      ; RECLASSIFY RESULT RANGE: MODIS NDVI & mNDWI
      OUTMIN = DOUBLE(OUTMIN)
      OUTMAX = DOUBLE(OUTMAX)
      ;
      ; GET MEAN
      OUTMEAN = MEAN(NEWDATA, /NAN)
      ; RECLASSIFY RESULT RANGE: MODIS NDVI & mNDWI
      OUTMEAN = DOUBLE(OUTMEAN)
      ;
      ; GET STDDEV: WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        OUTSTDDEV = 'NaN'
      ENDIF ELSE BEGIN
        OUTSTDDEV = STDDEV(NEWDATA, /NAN)
        ; RECLASSIFY RESULT RANGE: MODIS NDVI & mNDWI
        OUTSTDDEV = DOUBLE(OUTSTDDEV)
      ENDELSE
      ;
      ; GET MEDIAN
      OUTMEDIAN = MEDIAN(NEWDATA, DIMENSION=0, /EVEN)
      ; RECLASSIFY RESULT RANGE: MODIS NDVI & mNDWI
      OUTMEDIAN = DOUBLE(OUTMEDIAN)
      ;-----------------------------------------------------------------
      ; WRITE RESULTS TO OUTPUT
      PRINTF, FORMAT='(100000(A,:,","))', OUTLUN, j, '"'+ BANDNAME +'"', OUTDATE, YEARP, DOYP, '"'+ ROINAME +'"', $
        OUTMEAN, OUTSTDDEV, OUTMEDIAN, OUTMIN, OUTMAX, COUNT_TOTAL, COUNT_255, COUNT_VALID, EQ_255, $
        GE_NEG_0P9, GE_NEG_0P8, GE_NEG_0P7, GE_NEG_0P6, GE_NEG_0P5, GE_NEG_0P4, GE_NEG_0P3, GE_NEG_0P2, $
        GE_NEG_0P1,GE_NEG_0P05,GE_0,GT_0,GE_0P05, GE_0P1, GE_0P2, GE_0P3, GE_0P4, GE_0P5, $
        GE_0P6, GE_0P7, GE_0P8, GE_0P9
      ;-----------------------------------------------------------------
    ENDFOR ; FOR 'j' END
  ENDFOR ; FOR 'i' END
  ;---------------------------------------------------------------------
  ; CLOSE THE OUTPUT FILE
  FREE_LUN, OUTLUN
  PRINT,''
  ; PRINT THE PROCESSING TIME
  MINUTES = (SYSTIME(1)-F_TIME)/60
  PRINT, MINUTES,'  MINUTES'
  PRINT,''
  PRINT,'FINISHED PROCESSING: TIME_SERIES_SUMMARY_BY_VECTOR'
  PRINT,''
END