; ######################################################################
; NAME: EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION.pro
; LANGUAGE: IDL
; AUTHOR: Garth Warren 
; DATE: 31/09/2009
; DLM: 05/11/2009
; DESCRIPTION: This tool extracts a summary (mean, median, stddev, min 
;              & max) of the input cell data where the user-selected 
;              vector (ROI) intersect the input raster image.
;              The OWL version contains additional output fields;
;              the proportion of pixels that meet set OWL thresholds.
;              For example, 'PRCNT_GT_10' is the percentage of pixels
;              within the ROI that have an OWL value of greater than 10.
;              Note that NoData (cloud) pixels are excluded from the 
;              calculation.
; INPUT: Single or multi-band raster; polygon or point feature class
; OUTPUT: Text or CSV file (inc. file extension in output file name)
; SET PARAMETERS: WIDGET Based input; DEFINE OUTPUT CSV FILE, DEFINE 
;                 INPUT IMAGE DATA; DEFINE ROI. OTHER input; SET NODATA VALUES TO 
;                 NaN (set NoData Value)
; NOTES: A polygon or point vector must be opened in ENVI and associated
;        with the input raster data as a ROI. When extracting data at 
;        multiple polygon ROI please open each polygon as individual 
;        ROIs. * FIX TO REMOVE '% OF ALL' BUG
; ######################################################################
;
PRO EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION
  PRINT,''
  PRINT,'BEGIN PROCESSING: EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION'
  PRINT,'' 
  ;
  PRINT, '  DEFINE OUTPUT CSV FILE'
  ; DEFINE OUTPUT CSV FILE
  OUTFILE=DIALOG_PICKFILE(TITLE='Enter Output File Name')
  ; CHECK WHETHER THE OUTPUT FILE NAME AND PATH IS VALID
  IF OUTFILE EQ '' THEN BEGIN
  PRINT,''
  PRINT, 'The Selected Output File Name Is Not Valid'
  PRINT,''
  RETURN
  ENDIF
  ; CREATE THE EMPTY OUTPUT FILE
  OPENW, OUTLUN, OUTFILE, /GET_LUN
  ;
  PRINT, '  DEFINE INPUT IMAGE DATA'
  ; DEFINE INPUT IMAGE DATA (SINGLE OR MULTIBAND)
  ENVI_SELECT, TITLE='Select Input Image Data', FID=FID, POS=POS
  ; CHECK WHETHER THE INPUT IMAGE DATA NAME AND PATH IS VALID
  IF (FID EQ -1) THEN BEGIN
  PRINT,''
  PRINT, 'The Selected Image File Is Not Valid'
  PRINT,''
  RETURN
  ENDIF
  ENVI_FILE_QUERY, FID, BNAME=BNAME, SNAME=SNAME, NB=NB, DATA_TYPE=DATA_TYPE
  ; SET FILE COLUMN HEADER
  FNAME=["RASTERID","FILE&BAND","ROI","MEAN","STDDEV","MEDIAN","MIN","MAX","NO_255","NO_NOT_255","PRCT_EQ_255", $
    "PRCT_VALID_GT_10","PRCT_VALID_GT_20","PRCT_VALID_GT_30", "PRCT_VALID_GT_40","PRCT_VALID_GT_50", $
    "PRCT_VALID_GT_60","PRCT_VALID_GT_70","PRCT_VALID_GT_80","PRCT_VALID_GT_90","PRCT_ALL_GT_10", "PRCT_ALL_GT_20", $
    "PRCT_ALL_GT_30", "PRCT_ALL_GT_40","PRCT_ALL_GT_50","PRCT_ALL_GT_60","PRCT_ALL_GT_70", "PRCT_ALL_GT_80","PRCT_ALL_GT_90"]
  PRINTF, FORMAT='(10000(A,:,","))', OUTLUN, '"' + FNAME + '"'
  ; COUNT THE NUMBER OF BANDS IN THE INPUT FILE
  BCOUNT = WHERE(BNAME, COUNT)
  ;
  ;CHECK IF THE INPUT ROIs ARE ASSOCIATED WITH THE INPUT IMAGE DATA
  ROI_IDS = ENVI_GET_ROI_IDS(FID=FID, ROI_NAME=ROI_NAME, /SHORT_NAME)
  ; IF INPUT ROI IS NOT VALID PRINT... 
  IF (ROI_IDS[0] EQ -1) THEN BEGIN
  PRINT,''
  PRINT, 'There Is No ROI Associated With The Selected Input Image'
  PRINT,''
  RETURN
  ENDIF
  ;
  ; WIDGET FOR THE ROI SELECTION
  BASE = WIDGET_AUTO_BASE(TITLE='Select ROI')
  WM   = WIDGET_MULTI(BASE, LIST=ROI_NAME, UVALUE='LIST', /AUTO)
  RESULT = AUTO_WID_MNG(BASE)
  ;
  ; ERROR CHECK
  IF (RESULT.ACCEPT EQ 0) THEN RETURN
  PTR = WHERE(RESULT.LIST EQ 1, COUNT)
  ;
  ; ROI DATA EXTRACTION
  FOR i=0, COUNT-1 DO BEGIN
    ;
    ;INITIALISE VARIABLE TEMP_DATA TO HOLD ROI-BASED DATA
    DATA = ENVI_GET_ROI_DATA(ROI_IDS[PTR[i]], FID=FID, $
      POS=[0])
    TEMP_DATA = DBLARR(N_ELEMENTS(POS),N_ELEMENTS(DATA))
    ;
    ; ROI DATA EXTRACTION
    FOR j=0, N_ELEMENTS(POS)-1 DO BEGIN
      DATA = ENVI_GET_ROI_DATA(ROI_IDS[PTR[i]], FID=FID, $
        POS=POS[j])
      TEMP_DATA[j,*] = DATA
      ; GET ROI NAME
      RESULT = ENVI_GET_ROI(ROI_IDS[PTR[i]], ROI_NAME=ROI_NAME)            
      ;
      ; CALCULATE & WRITE
      ; CHECK DATA TYPE IS FLOAT
      IF DATA_TYPE LT 4 OR DATA_TYPE GT 5 THEN BEGIN
      ; CONVERT TEMP_DATA ARRAY TO FLOAT
      TEMP_DATA = FLOAT(TEMP_DATA)
      ENDIF
      ; GET OWL SUMMARY SPECIAL 1 ; THE PROPORTION OF VALUES THAT MEET THE SET CONDITION
      ; GET THE PERCENTAGE OF VALUES EQUAL TO NODATA
      NP0 = WHERE(TEMP_DATA[j,*] EQ 255.000, COUNT, NCOMPLEMENT=COUNT_NO)
      ; IF NO NAN VALUES
      IF COUNT EQ 0 THEN BEGIN
        COUNT = 0
        COUNT_NOD = DOUBLE(COUNT_NO)
        TOTALCOUNT = (COUNT + COUNT_NOD)
        NP0PROP = (COUNT/TOTALCOUNT)*100
        ;
        NO_NAN = COUNT
        NO_VALID = COUNT_NO
      ENDIF ELSE BEGIN
        ; IF NO VALID VALUES
        IF COUNT_NO EQ 0 THEN BEGIN
          COUNT_NO = 0
          COUNTD = DOUBLE(COUNT)
          TOTALCOUNT = (COUNTD + COUNT_NO)
          NP0PROP = (COUNTD/TOTALCOUNT)*100
          ;
          NO_NAN = COUNT
          NO_VALID = COUNT_NO
        ENDIF ELSE BEGIN
          ; IF THERE ARE NAN AND VALID VALUES
          COUNTD = DOUBLE(COUNT)
          COUNT_NOD = DOUBLE(COUNT_NO)
          TOTALCOUNT = (COUNTD + COUNT_NOD)
          NP0PROP = (COUNTD/TOTALCOUNT)*100
          ;
          NO_NAN = COUNT
          NO_VALID = COUNT_NO
        ENDELSE
      ENDELSE
      ; --------------------------------------------------------------------------------
      PRINT, '  CALCULATE ROI SUMMARY & WRITE'
      ; SET NODATA VALUES TO NaN IN TEMP_DATA ARRAY
      k = WHERE(TEMP_DATA EQ 255.000, COUNT)      
      IF (COUNT GT 0) THEN TEMP_DATA[k] = !VALUES.F_NAN
      ;
      ; GET OWL SUMMARY SPECIAL 2 ; THE PROPORTION OF VALUES THAT MEET THE SET CONDITION
      ; 
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 10
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP1PROP = 'NaN'
        NP1PROPx = 'NaN'
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP1 = WHERE(TEMP_DATA[j,*] LT 10.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP1PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP1PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP1PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP1PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ;   
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 20
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP2PROP = 'NaN'
        NP2PROPx = 'NaN'
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP2 = WHERE(TEMP_DATA[j,*] LT 20.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP2PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP2PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP2PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP2PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ;   
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 30
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP3PROP = 'NaN'
        NP3PROPx = 'NaN'
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP3 = WHERE(TEMP_DATA[j,*] LT 30.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP3PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP3PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP3PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP3PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ; 
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 40
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP4PROP = 'NaN'
        NP4PROPx = 'NaN' 
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP4 = WHERE(TEMP_DATA[j,*] LT 40.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP4PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP4PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP4PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP4PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ; 
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 50
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP5PROP = 'NaN' 
        NP5PROPx = 'NaN'
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP5 = WHERE(TEMP_DATA[j,*] LT 50.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP5PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP5PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP5PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP5PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ; 
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 60
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP6PROP = 'NaN'
        NP6PROPx = 'NaN'
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP6 = WHERE(TEMP_DATA[j,*] LT 60.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP6PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP6PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP6PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP6PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ; 
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 70
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP7PROP = 'NaN'
        NP7PROPx = 'NaN'
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP7 = WHERE(TEMP_DATA[j,*] LT 70.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP7PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP7PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP7PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP7PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ; 
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 80
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP8PROP = 'NaN'
        NP8PROPx = 'NaN' 
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP8 = WHERE(TEMP_DATA[j,*] LT 80.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP8PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP8PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP8PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP8PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ; 
      ; GET THE PERCENTAGE OF VALUES GREATER THAN 90
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        NP9PROP = 'NaN'
        NP9PROPx = 'NaN'
      ENDIF ELSE BEGIN
        ; GET COUNT OF VALUES THAT MEET CRITERIA
        NP9 = WHERE(TEMP_DATA[j,*] LT 90.000, COUNT)
        ; IF NO VALUES LESS THAN THRESHOLD
        IF COUNT EQ 0 THEN BEGIN
          COUNT = 0
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNT
          NP9PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP9PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDIF ELSE BEGIN
          ; IF VALUES LESS THAN THRESHOLD
          COUNTD = DOUBLE(COUNT)
          ;
          VALIDCOUNT = NO_VALID
          GRTCOUNT_VALID = VALIDCOUNT - COUNTD
          NP9PROP = (GRTCOUNT_VALID/VALIDCOUNT)
          ;
          TOTALCOUNT = (NO_NAN + NO_VALID)
          NP9PROPx = (GRTCOUNT_VALID/TOTALCOUNT)
        ENDELSE
      ENDELSE
      ;
      ; -------------------------------------------------------------------------------- 
      ; GET MIN MAX
      OUTMIN = MIN(TEMP_DATA[j,*], DIMENSION=0, MAX=OUTMAX, /NAN)
      ; GET MEAN
      OUTMEAN = MEAN(TEMP_DATA[j,*], /NAN) 
      ; GET STDDEV
      ; WHEN THERE ARE LESS THAN TWO 'REAL' NUMBERS IN THE ARRAY PRINT 'NaN'
      IF (N_ELEMENTS(WHERE(FINITE(TEMP_DATA[j,*]))) LT 2) THEN BEGIN
        OUTSTDDEV = 'NaN' 
      ENDIF ELSE BEGIN
        OUTSTDDEV = STDDEV(TEMP_DATA[j,*], /NAN)
      ENDELSE
      ;
      ; GET MEDIAN
      OUTMEDIAN = MEDIAN(TEMP_DATA[j,*], DIMENSION=0, /EVEN)
      ;
      ; WRITE THE ROI SUMMARY DATA TO THE OUTPUT CSV FILE
      ; GET BAND NAME
      NEWBNAME = BNAME[j]
      ; GET BAND & FILE NAME
      IRNAME = SNAME + ':' + BNAME[j]
      PRINTF, FORMAT='(10000(A,:,","))', OUTLUN, j, '"' + NEWBNAME + '"', '"' + ROI_NAME + '"', $
        OUTMEAN, OUTSTDDEV, OUTMEDIAN, OUTMIN, OUTMAX, NO_NAN, NO_VALID, NP0PROP, NP1PROP, $
        NP2PROP, NP3PROP, NP4PROP, NP5PROP, NP6PROP, NP7PROP, NP8PROP, NP9PROP, $ 
        NP1PROPx, NP2PROPx, NP3PROPx, NP4PROPx, NP5PROPx, NP6PROPx, NP7PROPx, NP8PROPx, NP9PROPx
      ;
      ; LOOP BACK TO THE NEXT ROI IN THE LIST
    ENDFOR
    ;
    ; LOOP BACK TO THE NEXT BAND IN THE LIST
  ENDFOR
  ;
  ; CLOSE THE OUTPUT FILE
  FREE_LUN, OUTLUN
  ;
  PRINT,''
  PRINT,'FINISHED PROCESSING: EXTRACT_RASTER_SUMMARY_BY_VECTOR_OWL_VERSION'
  PRINT,''
END